#!/usr/bin/env python3
"""
"Online" node simulator for developer tests.

Launches bitcoind in regtest mode, then constructs transactions as
expected by the developer tests. This simulates the online blockchain,
and is used to demonstrate that the transactions constructed by
glacierscript.py can be mined successfully.

See the interactive help for usage details.

The Makefile runs this in order to validate the withdrawal
transactions generated by GlacierScript.

"""

from abc import ABCMeta, abstractmethod
import argparse
from collections import defaultdict
from decimal import Decimal
import json
import os
import pprint
import re
import shutil
import subprocess
import sys
import textwrap
import time

from atomic_write import atomic_write
import segwit_addr
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import glacierscript  # noqa:pylint:wrong-import-position
from glacierscript import address_from_vout  # noqa:pylint:wrong-import-position
import bitcoin_cli    # noqa:pylint:wrong-import-position
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'trim-psbt'))
import trim_psbt


# Vars that glacierscript expects (ugh)
bitcoin_cli.cli_args = ["-regtest", "-datadir=bitcoin-online-data"]
glacierscript.wif_prefix = "EF"

MIN_FEE = Decimal("0.00010000")


def start(args):
    """Run the `start` subcommand to load bitcoind."""
    # We start with a pre-created wallet.dat so that our addresses
    # will be the same every time we run.
    stop(None)
    os.makedirs('bitcoin-online-data/regtest/wallets')
    shutil.copyfile(os.path.join(os.path.dirname(__file__), 'regtest-initial-wallet.dat'),
                    'bitcoin-online-data/regtest/wallets/wallet.dat')

    glacierscript.ensure_bitcoind_running('-txindex')
    mine_block(101)  # 101 so we have some coinbase outputs that are spendable
    # Load all transactions in tx.json and reconstruct those in our blockchain
    txfile = TxFile()
    for txdata in txfile:
        if 'txs' in txdata:
            if 'psbt' in txdata:
                raise RuntimeError("Didn't expect both txs and psbt in tx.json for " + txdata['file'])
            for hextx in txdata['txs']:
                recreate_tx(txdata, hextx)
        elif 'psbt' in txdata:
            recreate_psbt(txdata)
        else:
            raise RuntimeError("Expected either txs or psbt in tx.json for " + txdata['file'])
        if args.program == start:  # noqa:pylint:comparison-with-callable
            # If we're running `convert` then we allow runfile to differ, since
            # otherwise we wouldn't be able to change it and then re-convert it
            confirm_txs_in_runfile(txdata)


def recreate_tx(txdata, hextx):
    """
    Recreate one transaction from tx.json into our regtest blockchain.

    Make sure it matches what we got last time we started.
    """
    xact = build_input_xact(txdata['address'], hextx)
    # We should always create the same transactions, since we start
    # with a seeded wallet and tx.json is append-only.
    if xact != hextx:
        actual = bitcoin_cli.json("decoderawtransaction", xact)
        expected = bitcoin_cli.json("decoderawtransaction", hextx)
        print("Expected transaction:", file=sys.stderr)
        pprint.pprint(expected, stream=sys.stderr)
        print("Actual transaction constructed:", file=sys.stderr)
        pprint.pprint(actual, stream=sys.stderr)
        raise RuntimeError("Did not create expected transaction for " + txdata['file'])


class PsbtCreator(metaclass=ABCMeta):
    """
    Class for constructing a PSBT.

    We have three use cases for this: (1) loading the tx file, so that
    sign-psbt tests will find their expected inputs in the regtest
    blockchain, (2) converting a sign-psbt test from testnet to
    regtest, which means we need new txids for the inputs; and (3) the
    recreate-as-psbt subcommand. PSBTs created for #2 and #3 will then
    become use case #1 the next time we start up, so it had better
    construct the exact same PSBT.

    This base class is for sharing the common code; the details of
    what the PSBT inputs and outputs should look like are sufficiently
    different that I made those into two different subclasses.

    """

    def __init__(self, xact, trim):
        """Create new instance."""
        self.xact = xact
        self.trim = trim

    @abstractmethod
    def gen_witness_tuples(self):
        """Generate tuples of (amount, dest, sequence) for each input."""

    @abstractmethod
    def gen_input_txs(self):
        """Generate decoded transactions for each input."""

    @abstractmethod
    def outputs_like_tx(self):
        """Return decoded transaction with outputs to recreate."""

    def build_psbt(self):
        """Build and return a PSBT as a base64 string."""
        newinputs = []  # for the 'inputs' argument to `createpsbt`
        if self.xact.segwit:
            # For segwit, the PSBT will include only txid/vout/amount,
            # so we don't need to recreate any more than that.
            for amount, dest, sequence in self.gen_witness_tuples():
                crtinp = create_input2(amount, dest=dest)
                if sequence is not None:
                    crtinp['sequence'] = sequence
                newinputs.append(crtinp)
        else:
            # For non-segwit, the PSBT will include the entire input TX,
            # so we must recreate the entire input TX.
            for dectx in self.gen_input_txs():
                intx = build_input_xact_d(self.xact.source_address, dectx)
                decoded = bitcoin_cli.json("decoderawtransaction", intx)
                crtinp = {
                    'txid': decoded['txid'],
                    'vout': next(vout['n'] for vout in decoded['vout']
                                 if self.xact.source_address == address_from_vout(vout)),
                }
                newinputs.append(crtinp)
        # Now we have newinputs for `createpsbt`
        otx = self.outputs_like_tx()
        outputs = [{address_from_vout(vout): vout['value']}
                   for vout in otx['vout']]
        createpsbt = bitcoin_cli.checkoutput(
            "createpsbt",
            glacierscript.jsonstr(newinputs),
            glacierscript.jsonstr(outputs),
            '0',  # locktime
            # replaceable is determined by sequence numbers in recreate_witness_utxo
        ).strip()
        bitcoin_cli.checkoutput("lockunspent", 'false', glacierscript.jsonstr(newinputs))
        results = bitcoin_cli.json("walletprocesspsbt", createpsbt, 'false', 'ALL', 'false')
        return trim_psbt.strip(results['psbt']) if self.trim else results['psbt']


class PsbtPsbtCreator(PsbtCreator):
    """
    Construct a PSBT by mimicing another PSBT.

    Also imports its address & redeem script into the bitcoind wallet.

    Used for setting up PSBTs at start, so the sign-psbt tests will be
    able to find their expected inputs.

    Also used for converting testnet sign-psbt tests to regtest.

    """

    def __init__(self, rawpsbt, trim):
        """Create new instance; rawpsbt is base64 string."""
        self.rawpsbt = rawpsbt
        # Obviously we aren't creating a withdrawal, but constructing
        # this object does all the heavy lifting of decoding & importing:
        super().__init__(glacierscript.PsbtWithdrawalXact(self.rawpsbt), trim)
        self.psbt = self.xact.psbt

    def gen_witness_tuples(self):
        """Generate tuples of (amount, dest, sequence) for each input."""
        for index, inp in enumerate(self.psbt['inputs']):
            utxo = inp['witness_utxo']
            dest = utxo['scriptPubKey']['address']
            amount = utxo['amount']
            sequence = self.psbt['tx']['vin'][index]['sequence']
            yield (amount, dest, sequence)

    def gen_input_txs(self):
        """Generate decoded transactions for each input."""
        for inp in self.psbt['inputs']:
            yield inp['non_witness_utxo']

    def outputs_like_tx(self):
        """Return decoded transaction with outputs to recreate."""
        return self.psbt['tx']


class TxlistPsbtCreator(PsbtCreator):
    """
    Construct a PSBT by mimicing a list of input transactions.

    Also imports its address & redeem script into the bitcoind wallet.

    Used for recreate-as-psbt, to build a PSBT based off the input
    transactions and constructed outputs.

    """

    def __init__(self, filename, prf, decoded_tx, trim):
        """
        Create new instance.

        prf is ParsedRunfile
        decoded_tx is constructed withdrawal.
        """
        self.filename = filename
        self.prf = prf
        self.decoded_tx = decoded_tx
        # Start a withdrawal transaction just so it can figure out the
        # address details -- namely, segwit or not.
        super().__init__(glacierscript.ManualWithdrawalXact(
            prf.cold_storage_address, prf.redeem_script), trim)

    def gen_witness_tuples(self):
        """Generate tuples of (amount, dest, sequence) for each input."""
        for hextx in self.prf.input_txs:
            # Find any outputs to our address, which are the only
            # ones we care about. Typically there will be exactly one.
            txdec = bitcoin_cli.json("decoderawtransaction", hextx)
            for outp in txdec['vout']:
                if self.prf.cold_storage_address == address_from_vout(outp):
                    yield (outp['value'], self.prf.cold_storage_address, None)

    def gen_input_txs(self):
        """Generate decoded transactions for each input."""
        for rawtx in self.prf.input_txs:
            yield bitcoin_cli.json("decoderawtransaction", rawtx)

    def outputs_like_tx(self):
        """Return decoded transaction with outputs to recreate."""
        return self.decoded_tx


def recreate_psbt(txdata):
    """
    Import address from PSBT, recreate its inputs, recreate PSBT.

    Make sure it matches what we got last time we started.
    """
    rawpsbt = txdata['psbt']
    results_psbt = PsbtPsbtCreator(rawpsbt, txdata['trim']).build_psbt()
    if results_psbt != txdata['psbt']:
        actual = bitcoin_cli.json("decodepsbt", results_psbt)
        expected = bitcoin_cli.json("decodepsbt", txdata['psbt'])
        print("Expected PSBT:", file=sys.stderr)
        pprint.pprint(expected, stream=sys.stderr)
        print("Actual PSBT constructed:", file=sys.stderr)
        print(results_psbt, file=sys.stderr)
        pprint.pprint(actual, stream=sys.stderr)
        raise RuntimeError("Did not create expected PSBT for " + txdata['file'])


def confirm_txs_in_runfile(txdata):
    """
    Confirm the input txs in *.run file match tx.json.
    """
    if txdata['obsolete']:
        # This is an old transaction that we created only to keep
        # other tests' transactions from changing. Doesn't match any
        # *.run file anymore.
        return
    # Find *.run in t/ directory, same directory as this script
    runfile = os.path.join(os.path.dirname(__file__), txdata['file'])
    prf = ParsedRunfile.create(runfile)
    if 'txs' in txdata:
        match = set(txdata['txs']) == set(prf.input_txs)
    else:
        match = txdata['psbt'] == prf.psbt
    if not match:
        print("In file {}, found unexpected input transactions or PSBT.".format(runfile))
        print("If this file has deliberately changed, run `{} convert-testnet-to-regtest {}`".format(__file__, runfile))
        raise SystemExit("Error: Unexpected transaction in *.run file")


def mine_block(count=1):
    """
    Mine one or more blocks in our regtest blockchain.
    """
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    bitcoin_cli.json("generatetoaddress", "{}".format(count), adrs)


def create_input2(amount, *, addresstype='bech32', dest=None):
    """
    Create an input for an input (input^2).

    Because GlacierScript needs the entire transaction for each input,
    the format of the inputs to that transaction matter. This function
    will create transactions which become inputs to the transactions
    we feed to GlacierScript.

    addresstype: string: legacy, p2sh-segwit, or bech32
    amount: Decimal: amount in tBTC

    Returns an input in the format expected by createrawtransaction,
    e.g. a dict with keys txid, vout.

    Creates & mines transactions.
    """
    unspents = bitcoin_cli.json("listunspent")
    # Choose first unspent that's large enough. There should always be one because of
    # all our coinbase outputs of 50.0 BTC
    inputtx = next(unspent for unspent in unspents
                   if unspent["amount"] >= amount + MIN_FEE and unspent["spendable"])
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    dest_adrs = dest or bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    outputs = [
        {dest_adrs: amount}
    ]
    change_amount = inputtx["amount"] - amount - MIN_FEE
    if change_amount > 0:
        outputs.insert(0, {change_adrs: change_amount})

    hextx = create_and_mine([inputtx], outputs)

    txdec = bitcoin_cli.json("decoderawtransaction", hextx)
    # Find our vout. This is more flexible than necessary since we
    # fix the order of our two outputs above. It's always the last one.
    vout = next(vout for vout in txdec["vout"]
                if dest_adrs == address_from_vout(vout))
    return {
        "txid": txdec["txid"],
        "vout": vout["n"]
    }


def build_one_input2(vin, amount_btc):
    """
    Construct a single input for an input (input^2).

    vin: One entry from tx["vin"] that we want to reconstruct
    amount_btc: amount in BTC to put in this utxo

    Returns: one input in createrawtransaction form
    """
    # We have to parse scriptSig's asm to figure out what form this is
    # in (legacy, p2sh-segwit, or bech32),

    # The input could also be a multisig p2sh, or any other crazy
    # thing, but I don't think we need to support that.

    scriptsigs = {
        # Standard P2PKH: sig pubkey
        'legacy': r'sig: [0-9a-f]{140,144}\[ALL\] [0-9a-f]{66} witness: None',
        # P2WPKH-in-P2SH: (we won't always have the witness sigs, if it's a PSBT)
        'p2sh-segwit': r'sig: [0-9a-f]{44} witness: (None|[0-9a-f]{140,144} [0-9a-f]{66})',
        # P2WPKH:
        'bech32': r'sig:  witness: (None|[0-9a-f]{140,144} [0-9a-f]{66})',
    }
    witness = " ".join(vin["txinwitness"]) if "txinwitness" in vin else "None"
    vin_sig = "sig: {} witness: {}".format(vin["scriptSig"]["asm"], witness)
    try:
        form = next(f for f in scriptsigs if re.fullmatch(scriptsigs[f], vin_sig))
    except StopIteration as exc:
        raise NotImplementedError("unrecognized scriptsig in vin: {}".format(vin)) from exc
    return create_input2(amount_btc, addresstype=form)


def build_inputs2(like_tx):
    """
    Given a JSON decoded transaction, build the inputs needed.

    Returns: list of inputs in createrawtransaction form, which you
    can give directly to create_and_mine().

    """
    # The total value of all the inputs we create must add up to the
    # total outputs plus the min xact fee.
    total_output_btc = sum(vout["value"] for vout in like_tx["vout"])
    input_count = len(like_tx["vin"])
    each_input_btc = (total_output_btc + MIN_FEE) / input_count
    # Add one sat to each input (which will go to the miner fee)
    # so that rounding doesn't result in a less-than-min miner fee
    each_input_btc = each_input_btc.quantize(glacierscript.SATOSHI_PLACES) + glacierscript.SATOSHI_PLACES

    return [build_one_input2(vin, each_input_btc) for vin in like_tx["vin"]]


def build_one_inp_output(cold_address, vout):
    """
    Construct a single output for an input.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    vout: One entry from tx["vout"] that we want to reconstruct

    Returns: one output in createrawtransaction form,
    i.e. { address: amount }

    """
    if cold_address == address_from_vout(vout):
        return {cold_address: vout["value"]}

    # Decipher scriptPubKey.asm to determine address type (legacy, p2sh-segwit, bech32)
    type_conversion = {  # convert from scriptPubKey.type to getnewaddress type
        'pubkeyhash': 'legacy',
        'scripthash': 'p2sh-segwit',  # not necessarily true, but Glacier can't tell the difference
        'witness_v0_keyhash': 'bech32',
    }
    if vout["scriptPubKey"]["type"] not in type_conversion:
        raise NotImplementedError("unrecognized scriptPubKey type in vout: {}".format(vout))
    addr_type = type_conversion[vout["scriptPubKey"]["type"]]
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addr_type).strip()
    return {change_adrs: vout["value"]}


def build_inp_outputs(cold_address, like_tx):
    """
    Given a JSON decoded transaction, build the outputs needed.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    Returns: list of outputs in createrawtransaction form, which you
    can give directly to create_and_mine().

    """
    return [build_one_inp_output(cold_address, vout) for vout in like_tx["vout"]]


def build_input_xact(cold_address, like_this):
    """
    Construct a single transaction on the blockchain.

    As expected by one of our Glacier withdrawal tests.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    like_this: example transaction that we want the new one to look
    like.

    Returns: raw hex transaction.

    """
    return build_input_xact_d(
        cold_address,
        bitcoin_cli.json("decoderawtransaction", like_this)
    )


def build_input_xact_d(cold_address, like_tx):
    """Construct a single transaction, from already-decoded tx."""
    inputs = build_inputs2(like_tx)
    outputs = build_inp_outputs(cold_address, like_tx)
    return create_and_mine(inputs, outputs)


def create_and_mine(inputs, outputs):
    """
    Take the given inputs and outputs and put that transaction into the blockchain.

    inputs: <list> in createrawtransaction form

    Returns the raw hex transaction.
    """
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                    glacierscript.jsonstr(inputs),
                                    glacierscript.jsonstr(outputs)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    try:
        confirm_raw_tx(signedtx["hex"])
    except subprocess.CalledProcessError as exc:
        print("Failed to confirm tx:\n", exc.output)
        raise exc
    return signedtx["hex"]


def confirm_raw_tx(xact):
    """
    Given a raw transaction, submit that to bitcoind.

    Also mine it, and fail if it's not accepted.

    Bitcoind must already be running.
    """
    txid = bitcoin_cli.checkoutput("sendrawtransaction", xact).strip()
    mine_block()
    # Ensure that transaction was mined successfully
    rawtx = bitcoin_cli.json("getrawtransaction", txid, 'true')
    if rawtx["confirmations"] == 0:
        raise ValueError("somehow my xact did not get mined?")


def submit(args):
    """
    Given a golden output file, submit it to our blockchain.

    Proves that it validates.

    Also decode it into JSON and write it out to *.decoded file so Git
    can see the changes.
    """
    infile = args.goldenfile
    found = find_withdrawal_tx(infile)
    decoded_tx = ""
    if 'psbt' in found:
        decoded_tx += "\n".join(bitcoin_cli.checkoutput("decodepsbt", p) for p in found['psbt'])
    if 'rawtx' in found:
        if len(found['rawtx']) != 1:
            raise RuntimeError("How did we find more than one rawtx?")
        confirm_raw_tx(found['rawtx'][0])
        decoded_tx += bitcoin_cli.checkoutput("decoderawtransaction", found['rawtx'][0])
    elif 'psbt' in found:
        # Combine the psbts and confirm in the blockchain. First I
        # need the original PSBT for this test, since it has the full
        # details that the single-signed PSBTs from GlacierScript
        # might not have anymore.
        prf = ParsedRunfile.create(infile.replace('.golden', '.run'))
        unsigned_psbt = prf.psbt
        all_psbt_string = ", ".join('"' + x + '"' for x in [unsigned_psbt, *found['psbt']])
        combined = bitcoin_cli.checkoutput('combinepsbt', '[' + all_psbt_string + ']').strip()
        finalized = bitcoin_cli.json('finalizepsbt', combined)
        if not finalized['complete']:
            decoded_tx += "Combining {} PSBTs did not create a completed transaction".format(len(found['psbt']))
        else:
            confirm_raw_tx(finalized['hex'])
            decoded_tx += "online_regtest_wallet.py combined all PSBTs to form final transaction:\n"
            decoded_tx += bitcoin_cli.checkoutput("decoderawtransaction", finalized['hex'])
    else:
        decoded_tx = "No transaction found\n"
    write_decoded_tx(infile, decoded_tx)


def find_withdrawal_tx(infile):
    """
    Search infile for the withdrawal transaction generated by Glacier.

    infile: <string> filename of a *.golden file

    Returns a dict with keys:
     "rawtx": <list of strings> raw hex transaction, or
     "psbt": <list of strings> sequential-signed PSBTs

    Returns empty dict if unable to find either.
    """
    with open(infile, 'rt') as infh:
        # Find line following "Raw signed transaction (hex):"
        match = None
        found = defaultdict(list)
        for line in infh:
            if match:
                found[match].append(line.strip())
                match = None
            if line == "Raw signed transaction (hex):\n":
                match = 'rawtx'
            if line == "Incomplete PSBT (base64):\n":
                match = 'psbt'
    return found


def write_decoded_tx(infile, decoded_tx):
    """Write out the decoded_tx to the *.decoded file."""
    EXPECTED_SUFFIX = r"\.golden(\.re)?\Z"
    NEW_SUFFIX = ".decoded"
    decoded_file = re.sub(EXPECTED_SUFFIX, NEW_SUFFIX, infile)
    if not decoded_file.endswith(NEW_SUFFIX):
        raise ValueError("expected filename to end with " + EXPECTED_SUFFIX)
    with open(decoded_file, 'wt') as outfh:
        outfh.write(decoded_tx)


class TxFile():
    """
    Class to model tx.json file.

    This file keeps track of all the transactions we need to create
    which will be used as inputs to our test withdrawals.

    Why keep such a file?

    If a developer changes or adds a test, it's important for test
    stability that that test's new transactions get created after all
    the previous ones, including the ones previously used by that
    test.

    Otherwise, touching one test could change all the inputs used by
    all of the tests.

    Therefore, we keep track of even obsolete tests formerly used by a
    given *.run file. The tx.json file is effectively append-only:
    except for marking old transactions as obsolete, the only changes
    we make are to append new transactions to the end of the list. (By
    the `convert-testnet-to-regtest` subcommand.)

    """

    def __init__(self):
        """Load tx.json and populate our database."""
        with open(self._filename(), 'rt') as infile:
            infile.readline()  # first line is comment, throw away
            struct = infile.read()
            self.txlist = json.loads(struct)
        # Validate our assumption that no test has more than one
        # non-obsolete entry.
        found = set()
        for clump in (t for t in self.txlist if not t['obsolete']):
            if clump['file'] in found:
                raise RuntimeError("found multiple entries in tx.json for " + clump['file'])
            found.update(clump['file'])

    def __iter__(self):
        """Iterate over the transaction list."""
        return iter(self.txlist)

    @staticmethod
    def _filename():
        """Return filename including path of our tx.json."""
        return os.path.join(os.path.dirname(__file__), 'tx.json')

    def get(self, filename):
        """
        Return the tx.json structure for the specified *.run file.

        Returns None if this file is not in tx.json.
        """
        basefilename = os.path.basename(filename)
        try:
            return next(clump
                        for clump in self.txlist
                        if clump['file'] == basefilename and not clump['obsolete'])
        except StopIteration:
            return None

    def put(self, filename, *, cold_storage_address=None, txs=None, psbt=None, trim=None):
        """
        Replace the TX structures for the specified filename with txs.

        Mark any old txs as obsolete, append the
        new txs to the list, and write the list back to tx.json.
        """
        basefilename = os.path.basename(filename)
        new = {
            'file': basefilename,
            'obsolete': False,
        }
        if cold_storage_address:
            new['address'] = cold_storage_address
        if txs:
            new['txs'] = txs
        if psbt:
            new['psbt'] = psbt
        if trim is not None:
            new['trim'] = trim
        old = self.get(filename)
        if old:
            old['obsolete'] = True
        self.txlist.append(new)
        self.save()

    def save(self):
        """Write out new tx.json file."""
        with atomic_write(self._filename()) as outfile:
            outfile.write("// This file created and used by online_regtest_wallet.py\n")
            outfile.write(json.dumps(self.txlist, indent=2, sort_keys=True))
            outfile.write("\n")


class ParseError(RuntimeError):
    """Exception class for errors encountered in parsing a *.run file."""


class ParsedRunfile(metaclass=ABCMeta):
    """
    Representation of a *.run file.

    This class will parse a *.run file, convert its glacierscript
    command-line to use --regtest instead of --testnet, find the input
    transactions used, and present them as an API for possible
    modification. It can then write out the regenerated file.
    """

    def __init__(self, subcommand, filename):
        """Open file and parse it."""
        self.modified = False
        self.subcommand = subcommand
        self.filename = filename
        with open(filename, 'rt') as infile:
            contents = infile.read()
        self.parse_lines(contents)

    @staticmethod
    def create(filename):
        """Create an instance of the proper subclass, based on filename."""
        subclass_map = [
            ('create-withdrawal-data', CreateWithdrawalDataRunfile),
            ('sign-psbt', SignPsbtRunfile),
        ]
        for prefix, klass in subclass_map:
            if prefix in filename:
                return klass(prefix, filename)
        raise RuntimeError("Unrecognized test input filename: " + filename)

    def parser_coroutine(self, contents):
        """
        Accept a sequence of regexps that contents must match, yielding matched strings.

        The contents must match each regexp in order.

        Exits once all the contents have been consumed.
        """
        match = None
        while contents:
            regexp = yield match.group() if match else None
            match = re.match(regexp, contents, re.DOTALL | re.MULTILINE | re.VERBOSE)
            if not match:
                raise ParseError("did not match expected regexp in " + self.filename)
            contents = contents[match.end():]
        yield match.group()  # Last group...shouldn't ever return

    def _convert_tb1_to_bcrt1(self, addr):
        """
        Convert given address, if bech32, from testnet to regtest.

        (Old-style non-segwit addresses are identical on testnet vs regtest.)
        """
        if addr.startswith('tb1'):
            self.modified = True
            witver, witprog = segwit_addr.decode('tb', addr)
            return segwit_addr.encode('bcrt', witver, witprog)
        return addr

    @abstractmethod
    def parse_lines(self, contents):
        """Go through contents (one giant string) to find what we need."""

    def parse_beginning(self, contents):
        """
        Create parser, parse beginning of run file.

        Basically everything that's common between
        create-withdrawal-data and sign-psbt.

        Returns (parser, beginning_of_file).

        """
        parser = self.parser_coroutine(contents)
        next(parser)  # prime the coroutine
        opening = parser.send(r"""
                      \A     # beginning of file
                      .*?    # match as few as possible
                      ^      # beginning of line
                      \$GLACIERSCRIPT  # Run script
                      [^\n]* # any extra cmdline options (like -v)
                      \s+ -- # beginning of --testnet or --regtest
                   """)
        testmode = parser.send(r"""
                       (testnet|regtest)
                    """)
        if testmode == 'testnet':
            testmode = 'regtest'
            self.modified = True
        cmdline_and_confirm = parser.send(r"""
                            =\$1 \s""" + self.subcommand + r"""\s \<\< \s INPUT [^\n]*\n  # rest of cmdline
                            (y\n){6}       # safety confirmations
                        """)
        return (parser, opening + testmode + cmdline_and_confirm)

    def save(self):
        """Write out a new runfile with our modified input transactions."""
        if not self.modified:
            return
        with atomic_write(self.filename) as outfile:
            self.write_file_to(outfile)

    @abstractmethod
    def write_file_to(self, outfile):
        """Print file contents to the given filehandle."""


class CreateWithdrawalDataRunfile(ParsedRunfile):
    """Version of ParsedRunfile to handle create-withdrawal-data tests."""

    def __init__(self, subcommand, filename):
        """Create new instance."""
        self._input_txs = []
        self._input_tx_files = []
        super().__init__(subcommand, filename)

    @property
    def input_txs(self):
        """Return the list of input transactions used by this runfile."""
        return self._input_txs

    @input_txs.setter
    def input_txs(self, value):
        """Assign a new list of input transactions to replace the originals."""
        self.modified = True
        self._input_txs = value

    def parse_lines(self, contents):
        """Go through contents (one giant string) to find what we need."""
        parser, self.beginning_of_file = self.parse_beginning(contents)
        self.cold_storage_address = parser.send(r"""
                            (2[0-9a-zA-Z]+|(tb1|bcrt1)[0-9a-z]+) \n # cold storage address
                        """).strip()
        self.cold_storage_address = self._convert_tb1_to_bcrt1(self.cold_storage_address)

        self.redeem_script = parser.send(r"""
                                 [0-9a-fA-F]+ \n   # redeem script
                             """).strip()
        dest_address = parser.send(r"""
                            [0-9a-zA-Z]+ \n    # destination address
                        """).strip()
        dest_address = self._convert_tb1_to_bcrt1(dest_address)

        input_tx_count = int(parser.send(r"""
                            \d+ \n
                        """))
        self._input_txs = []
        self._input_tx_files = []
        for _ in range(input_tx_count):
            filename = None
            xact = parser.send(r"""
                               [^\n]+ \n   # input tx or filename with same
                               """).rstrip()
            if not re.match(r"^[0-9a-fA-F]+$", xact):
                # If not hex, this must be a filename
                filename = xact
                with open(filename, 'rt') as xfile:
                    xact = xfile.read().strip()
            self._input_txs.append(xact)
            self._input_tx_files.append(filename)

        back_matter = parser.send(r"""
                            .* \Z  # everything up to the end
                        """)
        self.front_matter = self.beginning_of_file \
            + self.cold_storage_address + "\n" \
            + self.redeem_script + "\n" \
            + dest_address + "\n" \
            + str(input_tx_count) \
            + "\n"
        self.back_matter = back_matter

    def find_keys(self):
        """
        Find the privkeys and return them as a list.

        Only run if we're doing recreate-as-psbt since not all
        create-withdrawal-data tests have any keys.
        """
        parser = self.parser_coroutine(self.back_matter)
        next(parser)  # prime the coroutine
        key_count = int(parser.send(r"""
            \d+ \n
        """))
        keys = []
        for _ in range(key_count):
            keys.append(parser.send(r"""
                [^\n]+ \n
            """).rstrip())
        return keys

    def write_file_to(self, outfile):
        """Print file contents to the given filehandle."""
        outfile.write(self.front_matter)
        for idx, xact in enumerate(self._input_txs):
            if self._input_tx_files[idx]:
                outfile.write(self._input_tx_files[idx] + "\n")
                with open(self._input_tx_files[idx], 'wt') as txfile:
                    txfile.write(xact + "\n")
            else:
                outfile.write(xact + "\n")

        outfile.write(self.back_matter)

    def convert_to_regtest(self):
        """
        Convert a testnet test to use regtest.

        It's important that our updates of tx.json happen before the
        *.run script is rewritten.  That way, if we get interrupted
        between those two, the next time we run, we'll find our
        transactions in tx.json and everything will just work. If we
        did it in the opposite order, we'd leave things in a broken
        state.

        """
        txjson = TxFile()
        tx_from_json = txjson.get(self.filename)
        if not tx_from_json \
           or tx_from_json['address'] != self.cold_storage_address \
           or set(tx_from_json['txs']) != set(self.input_txs):
            newtx = []
            converter = {}
            for hextx in self.input_txs:
                if hextx not in converter:
                    contx = build_input_xact(self.cold_storage_address, hextx)
                    newtx.append(contx)
                    converter[hextx] = contx
            self.input_txs = [converter[hextx] for hextx in self.input_txs]
            txjson.put(self.filename,
                       cold_storage_address=self.cold_storage_address,
                       txs=newtx)
        self.save()


class SignPsbtRunfile(ParsedRunfile):
    """Version of ParsedRunfile to handle sign-psbt tests."""

    def __init__(self, subcommand, filename):
        """Create new instance."""
        self._psbt = None
        self.psbt_filename = None
        super().__init__(subcommand, filename)

    @property
    def psbt(self):
        """Return the PSBT from this test."""
        return self._psbt

    @psbt.setter
    def psbt(self, value):
        """Set the PSBT to a new value."""
        self.modified = True
        self._psbt = value

    def parse_lines(self, contents):
        """Go through contents (one giant string) to find what we need."""
        parser, self.front_matter = self.parse_beginning(contents)

        self.psbt_filename = parser.send(r"""
                            [^\n]+ \n
                        """).strip()
        with open(self.psbt_filename, 'rt') as pfile:
            self._psbt = pfile.read().strip()

        self.back_matter = parser.send(r"""
                               .* \Z  # everything up to the end
                           """)

    def convert_to_regtest(self):
        """Convert a testnet test to use regtest."""
        txjson = TxFile()
        tx_from_json = txjson.get(self.filename)
        if not tx_from_json \
           or tx_from_json['psbt'] != self.psbt:
            trim = True
            self.psbt = PsbtPsbtCreator(self.psbt, trim).build_psbt()
            txjson.put(self.filename, psbt=self.psbt, trim=trim)
        self.save()

    def write_file_to(self, outfile):
        """Print file contents to the given filehandle."""
        outfile.write(self.front_matter)
        outfile.write(self.psbt_filename + "\n")
        outfile.write(self.back_matter)
        with open(self.psbt_filename, 'wt') as pfile:
            pfile.write(self.psbt + "\n")


def convert_one_file(filename):
    """Convert one *.run file from testnet to regtest."""
    runfile = ParsedRunfile.create(filename)
    runfile.convert_to_regtest()


def convert_testnet_to_regtest(args):
    """
    Parse a *.run test input, convert it from testnet to regtest (if needed).

    Save the generated input transactions in file tx.json,
    write out new *.run file with its input transactions replaced with regtest versions.

    We must run start() first, to be sure the current blockchain is in a known state,
    before we start creating additional transactions.
    """
    start(args)
    for runfile in args.runfile:
        print("Converting {} to regtest...".format(runfile))
        try:
            convert_one_file(runfile)
        except ParseError:
            print("*** Error converting that one. This is expected, if this test doesn't actually create any withdrawal transaction.")
    stop(args)


def recreate_as_psbt(args):
    """
    Take a create-withdrawal-test and duplicate it as PSBT.
    """
    start(args)
    print("Recreating {} as PSBT...".format(args.runfile))
    prf = ParsedRunfile.create(args.runfile)
    if prf.modified:
        raise RuntimeError("I can only convert regtest tests")
    if prf.subcommand != 'create-withdrawal-data':
        raise RuntimeError("I can only convert create-withdrawal-data tests")

    # I also need to see the Glacier-created withdrawal transaction so
    # I can see what the outputs should be.
    goldenfile = args.runfile.replace('.run', '.golden')
    found = find_withdrawal_tx(goldenfile)
    if 'rawtx' not in found:
        raise RuntimeError("I can only convert tests that successfully created a withdrawal")
    if 'psbt' in found:
        raise RuntimeError("How can a create-withdrawal-data test have output PSBTs?")
    if len(found['rawtx']) != 1:
        raise RuntimeError("How can a create-withdrawal-data test have more than one output transaction?")
    decoded_tx = bitcoin_cli.json("decoderawtransaction", found['rawtx'][0])

    trim = not args.no_trim
    psbt = TxlistPsbtCreator(args.runfile, prf, decoded_tx, trim).build_psbt()

    # Now that we have our raw PSBT, write that to a *.psbt file, and write
    # out a new runfile (make sure it's +x).
    begin = prf.beginning_of_file.replace("create-withdrawal-data", "sign-psbt")
    keys = prf.find_keys()
    destfilename = args.runfile.replace("create-withdrawal-data", "sign-psbt")
    psbtfilename = destfilename.replace(".run", ".psbt")
    goldenfilename = destfilename.replace(".run", ".golden")

    txjson = TxFile()
    txjson.put(destfilename, psbt=psbt, trim=trim)

    with open(destfilename, 'wt') as dest:
        print(begin, file=dest, end='')  # beginning_of_file already has a newline
        print(psbtfilename, file=dest)
        print("y", file=dest)
        print(str(len(keys)), file=dest)
        print("\n".join(keys), file=dest)
        print("y", file=dest)
        print("INPUT", file=dest)
    with open(psbtfilename, 'wt') as dest:
        print(psbt, file=dest)
    with open(goldenfilename, 'wt'):
        pass
    os.chmod(destfilename, 0o755)  # executable
    print("Successfully created {}, {}, and placeholder {}.".format(
        psbtfilename, destfilename, goldenfilename))
    stop(args)


def recreate_all_tests(args):
    """
    Recreate all transactions in tx.json and *.run.
    """
    print("Placeholder; TBD")


def stop(_):
    """
    Stop the bitcoind server.

    Does no harm if it's not running.
    """
    if bitcoin_cli.call('stop') == 0:
        # in case already running, wait a bit for it to exit
        time.sleep(1)

    try:
        shutil.rmtree('bitcoin-online-data')
    except FileNotFoundError:
        pass  # we don't care if it wasn't already there


def main():
    """Launch main command-line program."""
    parser = argparse.ArgumentParser(description="""
        This tool is used to control an "online" Bitcoin node for testing Glacier.
    """, epilog="Run <subcommand> --help for more about that subcommand.")
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    subparsers = parser.add_subparsers(title='Subcommands')

    parser_start = subparsers.add_parser(
        'start',
        help="Start the regtest server",
        description=textwrap.dedent("""\
        Start the regtest server and create transactions as expected
        by test withdrawals.

        This will read tx.json to find the list of transactions to
        create, and will parse all the *.run files to ensure that the
        transactions constructed match what the run files use as
        inputs.

        Glacier's Makefile runs this command once before running any
        tests.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_start.set_defaults(program=start)

    parser_submit = subparsers.add_parser(
        'submit',
        help="Submit a withdrawal transaction to the network",
        description=textwrap.dedent("""\
        Parse a *.golden test output, and submit its withdrawal
        transaction to bitcoind. Fail if not accepted and mined into
        the regtest blockchain. Also writes out a *.decoded file to
        document the constructed transaction in the git history.

        Glacier's Makefile runs this command after running any test
        with a filename of "create-withdrawal-data.*" or
        "sign-psbt.*", if the *.run file has --regtest in it.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_submit.set_defaults(program=submit)
    parser_submit.add_argument('goldenfile')

    parser_convert = subparsers.add_parser(
        'convert-testnet-to-regtest',
        help="Convert a test's *.run from testnet to regtest",
        description=textwrap.dedent("""\
        Parse one or more *.run files, which must be withdrawal tests,
        and look for transactions used as inputs. Convert each from
        testnet to regtest (if needed), save the generated input
        transactions in file tx.json, and write out new *.run files
        with all input transactions replaced with regtest versions.

        Running convert on an already-converted file has no effect.

        Test developers are expected to run this once after
        hand-creating any new tests via testnet.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_convert.set_defaults(program=convert_testnet_to_regtest)
    parser_convert.add_argument('runfile', nargs='+')

    parser_recreate = subparsers.add_parser(
        'recreate-as-psbt',
        help="Duplicate a withdrawal test into a PSBT version",
        description=textwrap.dedent("""\
        Take a create-withdrawal-data.*.run file and convert the
        withdrawal details into a PSBT, creating a new test named
        sign-psbt.*.run. The inputs and outputs of this PSBT will be
        of identical types and amounts as the original test case.

        This lets us quickly create lots of test cases for the
        sign-psbt flow (although many of the interesting cases are no
        longer interesting).
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_recreate.add_argument('--no-trim', action='store_true',
                                 help='Do not trim non-witness UTXO from PSBT')
    parser_recreate.set_defaults(program=recreate_as_psbt)
    parser_recreate.add_argument('runfile')

    parser_redoall = subparsers.add_parser(
        'recreate-all-tests',
        help="Recreate all withdrawal tests using new transactions",
        description=textwrap.dedent("""\
        Take all create-withdrawal-data.*.run and sign-psbt.*.run
        files and recreate the input transactions. Optionally remove
        obsolete transactions from tx.json.

        This is useful to handle changes in Bitcoin Core that change
        how regtest transactions are mined, such as #24732.

        Running this without any such changes (and without
        --trim-obsolete) should be safe and make no changes.

        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_redoall.add_argument('--trim-obsolete', action='store_true',
                                help='Remove obsolete transactions from tx.json')
    parser_redoall.set_defaults(program=recreate_all_tests)

    parser_stop = subparsers.add_parser(
        'stop',
        help="Stop the regtest server",
        description=textwrap.dedent("""\
        Stop the bitcoind regtest server started previously by the
        `start` subcommand, and delete the bitcoin-online-data dir
        that it was using as its data directory.

        Glacier's Makefile runs this command once after all tests
        pass.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_stop.set_defaults(program=stop)

    args = parser.parse_args()

    bitcoin_cli.verbose_mode = args.verbose

    if hasattr(args, 'program'):
        args.program(args)
    else:
        parser.print_usage()


if __name__ == "__main__":
    with glacierscript.subprocess_catcher():
        main()
