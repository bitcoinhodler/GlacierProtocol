#!/usr/bin/env python3

###################################################################
#
# online-regtest-wallet:
#
# Launches bitcoind in regtest mode, then constructs transactions as
# expected by the developer tests. This simulates the online
# blockchain, and is used to demonstrate that the transactions
# constructed by glacierscript.py can be mined successfully.
#
###################################################################

import argparse
from decimal import Decimal
import json
import os
import shutil
import sys
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import glacierscript
import bitcoin_cli

# Vars that glacierscript expects (ugh)
bitcoin_cli.cli_args = ["-regtest", "-datadir=bitcoin-online-data"]
glacierscript.wif_prefix = "EF"

MIN_FEE = Decimal("0.00010000")

def start(_):
    # We start with a pre-created wallet.dat so that our addressess
    # will be the same every time we run.
    if bitcoin_cli.call('stop') == 0:
        # in case already running, wait a bit for it to exit
        time.sleep(1)

    try:
        shutil.rmtree('bitcoin-online-data')
    except FileNotFoundError:
        pass  # we don't care if it wasn't already there
    os.makedirs('bitcoin-online-data/regtest/wallets')
    shutil.copyfile(os.path.join(os.path.dirname(__file__), 'regtest-initial-wallet.dat'),
                    'bitcoin-online-data/regtest/wallets/wallet.dat')

    glacierscript.ensure_bitcoind_running()
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    mine_block(101)  # 101 so we have some coinbase outputs that are spendable
    tx = build_input_xacts()
    print("Created this for p2sh-segwit:", tx)
    print("Signature is", glacierscript.hash_md5(tx.encode("ascii")))


def mine_block(count=1):
    """
    Mine one or more blocks in our regtest blockchain.
    """
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    bitcoin_cli.checkcall("generatetoaddress", "{}".format(count), adrs)


def create_input2(addresstype, amount):
    """
    Create an input for an input (input^2).

    Because GlacierScript needs the entire transaction for each input,
    the format of the inputs to that transaction matter. This function
    will create transactions which become inputs to the transactions
    we feed to GlacierScript.

    addresstype: string: legacy, p2sh-segwit, or bech32
    amount: Decimal: amount in tBTC

    Returns an input in the format expected by createrawtransaction,
    e.g. a dict with keys txid, vout.

    Creates & mines transactions.
    """
    unspents = bitcoin_cli.json("listunspent")
    # Choose first unspent that's large enough. There should always be one because of
    # all our coinbase outputs of 50.0 BTC
    input = next(unspent for unspent in unspents if unspent["amount"] >= amount)
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    dest_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    outputs = [
        { change_adrs: input["amount"] - amount - MIN_FEE },
        { dest_adrs: amount }
    ]
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                                  json.dumps([input], cls=glacierscript.DecimalEncoder),
                                                  json.dumps(outputs, cls=glacierscript.DecimalEncoder)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    confirm_raw_tx(signedtx["hex"])

    tx = bitcoin_cli.json("decoderawtransaction", signedtx["hex"])
    # Find our vout. This is more flexible than necessary since we
    # fix the order of our two outputs above.
    vout = next(vout for vout in tx["vout"] if dest_adrs in vout["scriptPubKey"]["addresses"])
    return {
        "txid": tx["txid"],
        "vout": vout["n"]
    }


def build_input_xacts():
    """
    Construct transactions on the blockchain as expected by our Glacier withdrawal tests.

    Returns: raw hex transaction for the one input expected by create-withdrawal-data.p2sh-segwit.run.
    Obviously this will change soon.
    """
    # Start with create-withdrawal-data.p2sh-segwit.run:
    inputs = [ create_input2('legacy', Decimal("1.0")) ]
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'legacy').strip()
    outputs = [
        { change_adrs: '0.89912787'},
        { '2N93du8YobdgsHyu3qgBvSyhGUT52utMNeA': '0.1' }
    ]
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                                  json.dumps(inputs, cls=glacierscript.DecimalEncoder),
                                                  json.dumps(outputs, cls=glacierscript.DecimalEncoder)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    confirm_raw_tx(signedtx["hex"])
    return signedtx["hex"]


def confirm_raw_tx(tx):
    """
    Given a raw transaction, submit that to bitcoind (which must
    already be running) and mine it, failing if it's not accepted.

    """
    txid = bitcoin_cli.checkoutput("sendrawtransaction", tx).strip()
    mine_block()
    # Ensure that transaction was mined successfully
    tx = bitcoin_cli.json("gettransaction", txid)
    if tx["confirmations"] != 1:
        raise ValueError("somehow my xact did not get mined?")


def stop(_):
    bitcoin_cli.checkcall("stop")

# HACK add cmdline option to transmit a transaction (and validate it)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    subparsers = parser.add_subparsers()

    parser_start = subparsers.add_parser('start')
    parser_start.set_defaults(program=start)

    parser_stop = subparsers.add_parser('stop')
    parser_stop.set_defaults(program=stop)

    args = parser.parse_args()

    bitcoin_cli.verbose_mode = args.verbose

    args.program(args)
