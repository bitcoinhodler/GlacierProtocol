#!/usr/bin/env python3

###################################################################
#
# online-regtest-wallet:
#
# Launches bitcoind in regtest mode, then constructs transactions as
# expected by the developer tests. This simulates the online
# blockchain, and is used to demonstrate that the transactions
# constructed by glacierscript.py can be mined successfully.
#
###################################################################

import argparse
from decimal import Decimal
import json
import os
import re
import shutil
import subprocess
import sys
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import glacierscript
import bitcoin_cli

# Vars that glacierscript expects (ugh)
bitcoin_cli.cli_args = ["-regtest", "-datadir=bitcoin-online-data"]
glacierscript.wif_prefix = "EF"

MIN_FEE = Decimal("0.00010000")

def start(_):
    # We start with a pre-created wallet.dat so that our addresses
    # will be the same every time we run.
    if bitcoin_cli.call('stop') == 0:
        # in case already running, wait a bit for it to exit
        time.sleep(1)

    try:
        shutil.rmtree('bitcoin-online-data')
    except FileNotFoundError:
        pass  # we don't care if it wasn't already there
    os.makedirs('bitcoin-online-data/regtest/wallets')
    shutil.copyfile(os.path.join(os.path.dirname(__file__), 'regtest-initial-wallet.dat'),
                    'bitcoin-online-data/regtest/wallets/wallet.dat')

    glacierscript.ensure_bitcoind_running()
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    mine_block(101)  # 101 so we have some coinbase outputs that are spendable
    # Start with create-withdrawal-data.p2sh-segwit.run. This raw transaction
    # came from testnet originally, created by some wallet software:
    tx = build_input_xact("2N93du8YobdgsHyu3qgBvSyhGUT52utMNeA", "0200000001a907b456e7dbfb35f45b229aef8da1ff03a2fe63af6ee118c61324b5d9cc6741000000006a47304402207d2fb9182111fdc889085ace7949f5e6ff1316842b621f866b6af7366ca1330d022034c72197a944353fd68d89b00248e4f33fc4f44da9611c19f0395addbf9eaca50121024c1eec1e8c61c41240027f30c334a808cb12e8513b7b83c95ad71adc99f794a9ffffffff02d3f55b05000000001976a9146efec32d8acafcf62f8aa1dacd69a7b703d72fba88ac809698000000000017a914ad50fb2489353008e75b0193011ff1f4b76f798c8700000000")
    print("Created this for p2sh-segwit:", tx)
    print("Signature is", glacierscript.hash_md5(tx.encode("ascii")))


def mine_block(count=1):
    """
    Mine one or more blocks in our regtest blockchain.
    Returns the block hash of the most recent block.
    """
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    block_hashes = bitcoin_cli.json("generatetoaddress", "{}".format(count), adrs)
    return block_hashes[-1]


def create_input2(addresstype, amount):
    """
    Create an input for an input (input^2).

    Because GlacierScript needs the entire transaction for each input,
    the format of the inputs to that transaction matter. This function
    will create transactions which become inputs to the transactions
    we feed to GlacierScript.

    addresstype: string: legacy, p2sh-segwit, or bech32
    amount: Decimal: amount in tBTC

    Returns an input in the format expected by createrawtransaction,
    e.g. a dict with keys txid, vout.

    Creates & mines transactions.
    """
    unspents = bitcoin_cli.json("listunspent")
    # Choose first unspent that's large enough. There should always be one because of
    # all our coinbase outputs of 50.0 BTC
    input = next(unspent for unspent in unspents if unspent["amount"] >= amount)
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    dest_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    outputs = [
        { change_adrs: input["amount"] - amount - MIN_FEE },
        { dest_adrs: amount }
    ]
    hextx = create_and_mine([input], outputs)

    tx = bitcoin_cli.json("decoderawtransaction", hextx)
    # Find our vout. This is more flexible than necessary since we
    # fix the order of our two outputs above. It's always the second one (n=1).
    vout = next(vout for vout in tx["vout"] if dest_adrs in vout["scriptPubKey"]["addresses"])
    return {
        "txid": tx["txid"],
        "vout": vout["n"]
    }


"""I'm wondering how I'm going to create all the inputs for all the
withdrawal tests, and how I can enable other users to add new tests.
Can I perhaps make a CSV file describing the inputs needed for each
test? Ugh, then I have to document that shit? Also I really want to
enable real wallet software to create real [testnet] deposits to
Glacier, so I can then test real withdrawals. Ugh, maybe this regtest
thing isn't such a bright idea after all?

OR: how about I keep this convert subprogram around indefinitely, so a
user who creates a real (testnet) deposit can feed it to us, and we
will convert it and provide it as output?

Workflow would still be pretty complex. Something like:

$ t/online-regtest-wallet convert create-withdrawal-data.2-of-3.run

The convert subprogram would:

* Parse the run file to find the input transaction(s)

* Look up the filename in our database (csv file?)

* Save all post-converted transactions in database. If they are the
  same as what we already have, don't change, If they are different? I
  assume for stability, we don't want to replace them, or reorder the
  other tests. So keep the old ones there, marked as obsolete, and add
  the new ones to the bottom.

* Write out a new run file with the converted transactions

Then the start subprogram will load this database, construct those
inputs in a deterministic manner, and check that the constructed
transactions match the database. Then, check every *.run file to see
that its input transactions still match what we have in the db,


Gah...this is all such a mess. Do I really want to do regtest?

The biggest issue is that we can't create deposits from non-bitcoind
wallets. But we do want to test such withdrawals!

"""

def build_one_input2(vin, amount_btc):
    """Construct a single input for an input (input^2).

    vin: One entry from tx["vin"] that we want to reconstruct
    amount_btc: amount in BTC to put in this utxo
    """
    # TODO: implement me
    return create_input2('legacy', Decimal("1.0"))


def build_inputs2(like_tx):
    """Given a JSON decoded transaction, build the inputs needed.

    Returns: list of inputs in createrawtransaction form, which you
    can give directly to create_and_mine().

    """
    # The total value of all the inputs we create must add up to the
    # total outputs plus the min xact fee.
    total_output_btc = sum(vout["value"] for vout in like_tx["vout"])
    input_count = len(like_tx["vin"])
    # Add one sat to each input (which will go to the miner fee)
    # so that rounding doesn't result in a less-than-min miner fee
    each_input_btc = (total_output_btc / input_count).quantize(glacierscript.SATOSHI_PLACES) + glacierscript.SATOSHI_PLACES

    return [ build_one_input2(vin, each_input_btc) for vin in like_tx["vin"] ]


def build_input_xact(cold_address, like_this):
    """Construct a single transaction on the blockchain as expected by
    one of our Glacier withdrawal tests.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    like_this: example transaction that we want the new one to look
    like.

    Returns: raw hex transaction.

    """
    like_tx = bitcoin_cli.json("decoderawtransaction", like_this)
    inputs = build_inputs2(like_tx)
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'legacy').strip()
    outputs = [
        { change_adrs: '0.89912787'},
        { cold_address: '0.1' }
    ]
    return create_and_mine(inputs, outputs)


def create_and_mine(inputs, outputs):
    """
    Take the given inputs and outputs (in createrawtransaction form)
    and put that transaction into the blockchain.

    Returns the raw hex transaction.
    """
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                    glacierscript.jsonstr(inputs),
                                    glacierscript.jsonstr(outputs)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    try:
        confirm_raw_tx(signedtx["hex"])
    except subprocess.CalledProcessError as e:
        print("Failed to confirm tx:\n", e.output)
        raise e
    return signedtx["hex"]


def confirm_raw_tx(tx):
    """
    Given a raw transaction, submit that to bitcoind (which must
    already be running) and mine it, failing if it's not accepted.

    """
    txid = bitcoin_cli.checkoutput("sendrawtransaction", tx).strip()
    block_hash = mine_block()
    # Ensure that transaction was mined successfully
    tx = bitcoin_cli.json("getrawtransaction", txid, 'true', block_hash)
    if tx["confirmations"] != 1:
        raise ValueError("somehow my xact did not get mined?")


class NoTransactionFound(Exception):
    """
    Raised when we cannot find a withdrawal transaction in the file we're searching.
    """


def submit(args):
    """
    Given a golden output file, submit it to our blockchain to prove
    that it validates.  Also decode it into JSON and write it out to
    *.decoded file so Git can see the changes.
    """
    infile = args.goldenfile
    try:
        rawtx = find_withdrawal_tx(infile)
        confirm_raw_tx(rawtx)
        decoded_tx = bitcoin_cli.checkoutput("decoderawtransaction", rawtx)
    except NoTransactionFound:
        decoded_tx = "No transaction found\n"
    write_decoded_tx(infile, decoded_tx)


def find_withdrawal_tx(infile):
    """
    Search infile, which is a test's golden output, for the withdrawal
    transaction generated by Glacier.

    Returns the rawtx as a string, or raises NoTransactionFound.

    """
    with open(infile, 'rt') as f:
        # Find line following "Raw signed transaction (hex):"
        match = False
        for line in f:
            if match:
                return line.strip()
            if line == "Raw signed transaction (hex):\n":
                match = True
    raise NoTransactionFound()



def write_decoded_tx(infile, decoded_tx):
    """
    Write out the decoded_tx to the *.decoded file.
    """
    EXPECTED_SUFFIX = r"\.golden(\.re)?\Z"
    NEW_SUFFIX = ".decoded"
    decoded_file = re.sub(EXPECTED_SUFFIX, NEW_SUFFIX, infile)
    if not decoded_file.endswith(NEW_SUFFIX):
        raise ValueError("expected filename to end with " + EXPECTED_SUFFIX)
    with open(decoded_file, 'wt') as f:
        f.write(decoded_tx)


def stop(_):
    bitcoin_cli.checkcall("stop")



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
        This tool is used to control an "online" Bitcoin node for testing Glacier.
    """)
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    subparsers = parser.add_subparsers()

    parser_start = subparsers.add_parser('start', help="""
        Start the regtest server and create transactions as expected by test withdrawals.
    """)
    parser_start.set_defaults(program=start)

    parser_submit = subparsers.add_parser('submit', help="""
        Parse a *.golden test output, submit its withdrawal transaction to bitcoind.
    """)
    parser_submit.set_defaults(program=submit)
    parser_submit.add_argument('goldenfile')

    parser_stop = subparsers.add_parser('stop', help="""
        Stop the regtest server.
    """)
    parser_stop.set_defaults(program=stop)

    args = parser.parse_args()

    bitcoin_cli.verbose_mode = args.verbose

    args.program(args)
