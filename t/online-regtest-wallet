#!/usr/bin/env python3

###################################################################
#
# online-regtest-wallet:
#
# Launches bitcoind in regtest mode, then constructs transactions as
# expected by the developer tests. This simulates the online
# blockchain, and is used to demonstrate that the transactions
# constructed by glacierscript.py can be mined successfully.
#
###################################################################

import argparse
from decimal import Decimal
import json
import os
import re
import shutil
import sys
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import glacierscript
import bitcoin_cli

# Vars that glacierscript expects (ugh)
bitcoin_cli.cli_args = ["-regtest", "-datadir=bitcoin-online-data"]
glacierscript.wif_prefix = "EF"

MIN_FEE = Decimal("0.00010000")

def start(_):
    # We start with a pre-created wallet.dat so that our addresses
    # will be the same every time we run.
    if bitcoin_cli.call('stop') == 0:
        # in case already running, wait a bit for it to exit
        time.sleep(1)

    try:
        shutil.rmtree('bitcoin-online-data')
    except FileNotFoundError:
        pass  # we don't care if it wasn't already there
    os.makedirs('bitcoin-online-data/regtest/wallets')
    shutil.copyfile(os.path.join(os.path.dirname(__file__), 'regtest-initial-wallet.dat'),
                    'bitcoin-online-data/regtest/wallets/wallet.dat')

    glacierscript.ensure_bitcoind_running()
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    mine_block(101)  # 101 so we have some coinbase outputs that are spendable
    tx = build_input_xacts()
    print("Created this for p2sh-segwit:", tx)
    print("Signature is", glacierscript.hash_md5(tx.encode("ascii")))


def mine_block(count=1):
    """
    Mine one or more blocks in our regtest blockchain.
    Returns the block hash of the most recent block.
    """
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    block_hashes = bitcoin_cli.json("generatetoaddress", "{}".format(count), adrs)
    return block_hashes[-1]


def create_input2(addresstype, amount):
    """
    Create an input for an input (input^2).

    Because GlacierScript needs the entire transaction for each input,
    the format of the inputs to that transaction matter. This function
    will create transactions which become inputs to the transactions
    we feed to GlacierScript.

    addresstype: string: legacy, p2sh-segwit, or bech32
    amount: Decimal: amount in tBTC

    Returns an input in the format expected by createrawtransaction,
    e.g. a dict with keys txid, vout.

    Creates & mines transactions.
    """
    unspents = bitcoin_cli.json("listunspent")
    # Choose first unspent that's large enough. There should always be one because of
    # all our coinbase outputs of 50.0 BTC
    input = next(unspent for unspent in unspents if unspent["amount"] >= amount)
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    dest_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    outputs = [
        { change_adrs: input["amount"] - amount - MIN_FEE },
        { dest_adrs: amount }
    ]
    hextx = create_and_mine([input], outputs)

    tx = bitcoin_cli.json("decoderawtransaction", hextx)
    # Find our vout. This is more flexible than necessary since we
    # fix the order of our two outputs above. It's always the second one (n=1).
    vout = next(vout for vout in tx["vout"] if dest_adrs in vout["scriptPubKey"]["addresses"])
    return {
        "txid": tx["txid"],
        "vout": vout["n"]
    }


def build_input_xacts():
    """
    Construct transactions on the blockchain as expected by our Glacier withdrawal tests.

    Returns: raw hex transaction for the one input expected by create-withdrawal-data.p2sh-segwit.run.
    Obviously this will change soon.
    """
    # Start with create-withdrawal-data.p2sh-segwit.run:
    inputs = [ create_input2('legacy', Decimal("1.0")) ]
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'legacy').strip()
    outputs = [
        { change_adrs: '0.89912787'},
        { '2N93du8YobdgsHyu3qgBvSyhGUT52utMNeA': '0.1' }
    ]
    return create_and_mine(inputs, outputs)


def create_and_mine(inputs, outputs):
    """
    Take the given inputs and outputs (in createrawtransaction form)
    and put that transaction into the blockchain.

    Returns the raw hex transaction.
    """
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                    glacierscript.jsonstr(inputs),
                                    glacierscript.jsonstr(outputs)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    confirm_raw_tx(signedtx["hex"])
    return signedtx["hex"]


def confirm_raw_tx(tx):
    """
    Given a raw transaction, submit that to bitcoind (which must
    already be running) and mine it, failing if it's not accepted.

    """
    txid = bitcoin_cli.checkoutput("sendrawtransaction", tx).strip()
    block_hash = mine_block()
    # Ensure that transaction was mined successfully
    tx = bitcoin_cli.json("getrawtransaction", txid, 'true', block_hash)
    if tx["confirmations"] != 1:
        raise ValueError("somehow my xact did not get mined?")


class NoTransactionFound(Exception):
    """
    Raised when we cannot find a withdrawal transaction in the file we're searching.
    """


def submit(args):
    """
    Given a golden output file, submit it to our blockchain to prove
    that it validates.  Also decode it into JSON and write it out to
    *.decoded file so Git can see the changes.
    """
    infile = args.goldenfile
    try:
        rawtx = find_withdrawal_tx(infile)
        confirm_raw_tx(rawtx)
        decoded_tx = bitcoin_cli.checkoutput("decoderawtransaction", rawtx)
    except NoTransactionFound:
        decoded_tx = "No transaction found\n"
    write_decoded_tx(infile, decoded_tx)


def find_withdrawal_tx(infile):
    """
    Search infile, which is a test's golden output, for the withdrawal
    transaction generated by Glacier.

    Returns the rawtx as a string, or raises NoTransactionFound.

    """
    with open(infile, 'rt') as f:
        # Find line following "Raw signed transaction (hex):"
        match = False
        for line in f:
            if match:
                return line.strip()
            if line == "Raw signed transaction (hex):\n":
                match = True
    raise NoTransactionFound()



def write_decoded_tx(infile, decoded_tx):
    """
    Write out the decoded_tx to the *.decoded file.
    """
    EXPECTED_SUFFIX = r"\.golden(\.re)?\Z"
    NEW_SUFFIX = ".decoded"
    decoded_file = re.sub(EXPECTED_SUFFIX, NEW_SUFFIX, infile)
    if not decoded_file.endswith(NEW_SUFFIX):
        raise ValueError("expected filename to end with " + EXPECTED_SUFFIX)
    with open(decoded_file, 'wt') as f:
        f.write(decoded_tx)


def stop(_):
    bitcoin_cli.checkcall("stop")

# HACK add cmdline option to transmit a transaction (and validate it)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
        This tool is used to control an "online" Bitcoin node for testing Glacier.
    """)
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    subparsers = parser.add_subparsers()

    parser_start = subparsers.add_parser('start', help="""
        Start the regtest server and create transactions as expected by test withdrawals.
    """)
    parser_start.set_defaults(program=start)

    parser_submit = subparsers.add_parser('submit', help="""
        Parse a *.golden test output, submit its withdrawal transaction to bitcoind.
    """)
    parser_submit.set_defaults(program=submit)
    parser_submit.add_argument('goldenfile')

    parser_stop = subparsers.add_parser('stop', help="""
        Stop the regtest server.
    """)
    parser_stop.set_defaults(program=stop)

    args = parser.parse_args()

    bitcoin_cli.verbose_mode = args.verbose

    args.program(args)
