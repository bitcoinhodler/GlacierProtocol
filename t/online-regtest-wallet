#!/usr/bin/env python3

###################################################################
#
# online-regtest-wallet:
#
# Launches bitcoind in regtest mode, then constructs transactions as
# expected by the developer tests. This simulates the online
# blockchain, and is used to demonstrate that the transactions
# constructed by glacierscript.py can be mined successfully.
#
###################################################################

import argparse
from decimal import Decimal
import json
import os
import re
import shutil
import subprocess
import sys
import textwrap
import time

from atomic_write import atomic_write
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import glacierscript
import bitcoin_cli

# Vars that glacierscript expects (ugh)
bitcoin_cli.cli_args = ["-regtest", "-datadir=bitcoin-online-data"]
glacierscript.wif_prefix = "EF"

MIN_FEE = Decimal("0.00010000")

def start(_):
    # We start with a pre-created wallet.dat so that our addresses
    # will be the same every time we run.
    stop(None)
    os.makedirs('bitcoin-online-data/regtest/wallets')
    shutil.copyfile(os.path.join(os.path.dirname(__file__), 'regtest-initial-wallet.dat'),
                    'bitcoin-online-data/regtest/wallets/wallet.dat')

    glacierscript.ensure_bitcoind_running()
    # TODO: remove this mistaken line, which will change the transactions created,
    # and make sure we catch that the transactions have changed.
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    mine_block(101)  # 101 so we have some coinbase outputs that are spendable
    # Start with create-withdrawal-data.p2sh-segwit.run. This raw transaction
    # came from testnet originally, created by some wallet software:
    tx = build_input_xact("2N93du8YobdgsHyu3qgBvSyhGUT52utMNeA", "0200000001a907b456e7dbfb35f45b229aef8da1ff03a2fe63af6ee118c61324b5d9cc6741000000006a47304402207d2fb9182111fdc889085ace7949f5e6ff1316842b621f866b6af7366ca1330d022034c72197a944353fd68d89b00248e4f33fc4f44da9611c19f0395addbf9eaca50121024c1eec1e8c61c41240027f30c334a808cb12e8513b7b83c95ad71adc99f794a9ffffffff02d3f55b05000000001976a9146efec32d8acafcf62f8aa1dacd69a7b703d72fba88ac809698000000000017a914ad50fb2489353008e75b0193011ff1f4b76f798c8700000000")
    print("Created this for p2sh-segwit:", tx)
    print("Signature is", glacierscript.hash_md5(tx.encode("ascii")))


def mine_block(count=1):
    """
    Mine one or more blocks in our regtest blockchain.
    Returns the block hash of the most recent block.
    """
    adrs = bitcoin_cli.checkoutput("getnewaddress", '', 'p2sh-segwit').strip()
    block_hashes = bitcoin_cli.json("generatetoaddress", "{}".format(count), adrs)
    return block_hashes[-1]


def create_input2(addresstype, amount):
    """
    Create an input for an input (input^2).

    Because GlacierScript needs the entire transaction for each input,
    the format of the inputs to that transaction matter. This function
    will create transactions which become inputs to the transactions
    we feed to GlacierScript.

    addresstype: string: legacy, p2sh-segwit, or bech32
    amount: Decimal: amount in tBTC

    Returns an input in the format expected by createrawtransaction,
    e.g. a dict with keys txid, vout.

    Creates & mines transactions.
    """
    unspents = bitcoin_cli.json("listunspent")
    # Choose first unspent that's large enough. There should always be one because of
    # all our coinbase outputs of 50.0 BTC
    input = next(unspent for unspent in unspents if unspent["amount"] >= amount)
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    dest_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addresstype).strip()
    outputs = [
        { change_adrs: input["amount"] - amount - MIN_FEE },
        { dest_adrs: amount }
    ]
    hextx = create_and_mine([input], outputs)

    tx = bitcoin_cli.json("decoderawtransaction", hextx)
    # Find our vout. This is more flexible than necessary since we
    # fix the order of our two outputs above. It's always the second one (n=1).
    vout = next(vout for vout in tx["vout"] if dest_adrs in vout["scriptPubKey"]["addresses"])
    return {
        "txid": tx["txid"],
        "vout": vout["n"]
    }


"""I'm wondering how I'm going to create all the inputs for all the
withdrawal tests, and how I can enable other users to add new tests.
Can I perhaps make a CSV file describing the inputs needed for each
test? Ugh, then I have to document that shit? Also I really want to
enable real wallet software to create real [testnet] deposits to
Glacier, so I can then test real withdrawals. Ugh, maybe this regtest
thing isn't such a bright idea after all?

OR: how about I keep this convert subprogram around indefinitely, so a
user who creates a real (testnet) deposit can feed it to us, and we
will convert it and provide it as output?

Workflow would still be pretty complex. Something like:

$ t/online-regtest-wallet convert create-withdrawal-data.2-of-3.run

The convert subprogram would:

* Parse the run file to find the input transaction(s)

* Look up the filename in our database (csv file?)

* Save all post-converted transactions in database. If they are the
  same as what we already have, don't change, If they are different? I
  assume for stability, we don't want to replace them, or reorder the
  other tests. So keep the old ones there, marked as obsolete, and add
  the new ones to the bottom.

* Write out a new run file with the converted transactions

Then the start subprogram will load this database, construct those
inputs in a deterministic manner, and check that the constructed
transactions match the database. Then, check every *.run file to see
that its input transactions still match what we have in the db,


Gah...this is all such a mess. Do I really want to do regtest?

The biggest issue is that we can't create deposits from non-bitcoind
wallets. But we do want to test such withdrawals!

"""

def build_one_input2(vin, amount_btc):
    """Construct a single input for an input (input^2).

    vin: One entry from tx["vin"] that we want to reconstruct
    amount_btc: amount in BTC to put in this utxo

    Returns: one input in createrawtransaction form
    """
    # We have to parse scriptSig's asm to figure out what form this is
    # in (legacy, p2sh-segwit, or bech32),

    # TODO: the input could also be a multisig p2sh, or any other
    # crazy thing. Do we need to be able to construct such things?

    scriptsigs = {
        # Standard P2PKH: sig pubkey
        # TODO: the sig might not always be precisely 140 chars
        'legacy': r'[0-9a-f]{140}\[ALL\] [0-9a-f]{66}',
    }
    vin_sig = vin["scriptSig"]["asm"]
    form = next(f for f in scriptsigs.keys() if re.fullmatch(scriptsigs[f], vin_sig))
    if not form:
        raise NotImplementedError("unrecognized scriptsig in vin: {}".format(vin))
    return create_input2(form, amount_btc)


def build_inputs2(like_tx):
    """Given a JSON decoded transaction, build the inputs needed.

    Returns: list of inputs in createrawtransaction form, which you
    can give directly to create_and_mine().

    """
    # The total value of all the inputs we create must add up to the
    # total outputs plus the min xact fee.
    total_output_btc = sum(vout["value"] for vout in like_tx["vout"])
    input_count = len(like_tx["vin"])
    each_input_btc = (total_output_btc + MIN_FEE) / input_count
    # Add one sat to each input (which will go to the miner fee)
    # so that rounding doesn't result in a less-than-min miner fee
    each_input_btc = each_input_btc.quantize(glacierscript.SATOSHI_PLACES) + glacierscript.SATOSHI_PLACES

    return [ build_one_input2(vin, each_input_btc) for vin in like_tx["vin"] ]


def build_one_inp_output(cold_address, vout):
    """Construct a single output for an input.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    vout: One entry from tx["vout"] that we want to reconstruct

    Returns: one output in createrawtransaction form,
    i.e. { address: amount }

    """
    if cold_address in vout["scriptPubKey"]["addresses"]:
        return { cold_address: vout["value"] }

    # Decipher scriptPubKey.asm to determine address type (legacy, p2sh-segwit, bech32)
    type_conversion = {  # convert from scriptPubKey.type to getnewaddress type
        'pubkeyhash'        : 'legacy',
        'scripthash'        : 'p2sh-segwit',  # not necessarily true, but Glacier can't tell the difference
        'witness_v0_keyhash': 'bech32',
    }
    if vout["scriptPubKey"]["type"] not in type_conversion:
        raise NotImplementedError("unrecognized scriptPubKey type in vout: {}".format(vout))
    addr_type = type_conversion[vout["scriptPubKey"]["type"]]
    change_adrs = bitcoin_cli.checkoutput("getnewaddress", '', addr_type).strip()
    return { change_adrs: vout["value"] }


def build_inp_outputs(cold_address, like_tx):
    """Given a JSON decoded transaction, build the outputs needed.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    Returns: list of outputs in createrawtransaction form, which you
    can give directly to create_and_mine().

    """
    return [ build_one_inp_output(cold_address, vout) for vout in like_tx["vout"] ]


def build_input_xact(cold_address, like_this):
    """Construct a single transaction on the blockchain as expected by
    one of our Glacier withdrawal tests.

    cold_address: Glacier-created cold storage address that this
    transaction should deposit to

    like_this: example transaction that we want the new one to look
    like.

    Returns: raw hex transaction.

    """
    like_tx = bitcoin_cli.json("decoderawtransaction", like_this)
    inputs = build_inputs2(like_tx)
    outputs = build_inp_outputs(cold_address, like_tx)
    return create_and_mine(inputs, outputs)


def create_and_mine(inputs, outputs):
    """
    Take the given inputs and outputs (in createrawtransaction form)
    and put that transaction into the blockchain.

    Returns the raw hex transaction.
    """
    rawtx = bitcoin_cli.checkoutput("createrawtransaction",
                                    glacierscript.jsonstr(inputs),
                                    glacierscript.jsonstr(outputs)).strip()
    signedtx = bitcoin_cli.json("signrawtransactionwithwallet", rawtx)
    if not signedtx["complete"]:
        raise ValueError("unable to sign transaction")
    try:
        confirm_raw_tx(signedtx["hex"])
    except subprocess.CalledProcessError as e:
        print("Failed to confirm tx:\n", e.output)
        raise e
    return signedtx["hex"]


def confirm_raw_tx(tx):
    """
    Given a raw transaction, submit that to bitcoind (which must
    already be running) and mine it, failing if it's not accepted.

    """
    txid = bitcoin_cli.checkoutput("sendrawtransaction", tx).strip()
    block_hash = mine_block()
    # Ensure that transaction was mined successfully
    tx = bitcoin_cli.json("getrawtransaction", txid, 'true', block_hash)
    if tx["confirmations"] != 1:
        raise ValueError("somehow my xact did not get mined?")


class NoTransactionFound(Exception):
    """
    Raised when we cannot find a withdrawal transaction in the file we're searching.
    """


def submit(args):
    """
    Given a golden output file, submit it to our blockchain to prove
    that it validates.  Also decode it into JSON and write it out to
    *.decoded file so Git can see the changes.
    """
    infile = args.goldenfile
    try:
        rawtx = find_withdrawal_tx(infile)
        confirm_raw_tx(rawtx)
        decoded_tx = bitcoin_cli.checkoutput("decoderawtransaction", rawtx)
    except NoTransactionFound:
        decoded_tx = "No transaction found\n"
    write_decoded_tx(infile, decoded_tx)


def find_withdrawal_tx(infile):
    """
    Search infile, which is a test's golden output, for the withdrawal
    transaction generated by Glacier.

    Returns the rawtx as a string, or raises NoTransactionFound.

    """
    with open(infile, 'rt') as f:
        # Find line following "Raw signed transaction (hex):"
        match = False
        for line in f:
            if match:
                return line.strip()
            if line == "Raw signed transaction (hex):\n":
                match = True
    raise NoTransactionFound()



def write_decoded_tx(infile, decoded_tx):
    """
    Write out the decoded_tx to the *.decoded file.
    """
    EXPECTED_SUFFIX = r"\.golden(\.re)?\Z"
    NEW_SUFFIX = ".decoded"
    decoded_file = re.sub(EXPECTED_SUFFIX, NEW_SUFFIX, infile)
    if not decoded_file.endswith(NEW_SUFFIX):
        raise ValueError("expected filename to end with " + EXPECTED_SUFFIX)
    with open(decoded_file, 'wt') as f:
        f.write(decoded_tx)


class TxFile():
    """Class to model tx.json file.

    This file keeps track of all the transactions we need to create
    which will be used as inputs to our test withdrawals.

    If a developer changes a test, it's important for test stability
    that that test's new transactions get created after all the
    previous ones, including the ones previously used by that test.

    Otherwise, touching one test could change all the inputs used by
    all of the tests.

    Therefore, we keep track of even obsolete tests formerly used by a
    given *.run file. The tx.json file is effectively append-only:
    except for marking old transactions as obsolete, the only changes
    we make are to append new transactions to the end of the list. (By
    the `convert` subcommand.)

    """

    def __init__(self):
        """Load tx.json and populate our database."""
        raise NotImplementedError()

    def get(self, filename):
        """Return a list of TX structures for the specified *.run file."""
        raise NotImplementedError()

    def put(self, filename, txs):
        """Replace the TX structures for the specified filename with txs.

        If txs matches the previous TXs for that filename, do nothing.

        If txs is different, mark the old txs as obsolete, append the
        new txs to the list, and write the list back to tx.json.
        """
        raise NotImplementedError()


class ParseError(RuntimeError):
    """Exception class for errors encountered in parsing a *.run file."""


class ParsedRunfile():
    """
    Representation of a *.run file.

    This class will parse a *.run file, convert its glacierscript
    command-line to use --regtest instead of --testnet, find the input
    transactions used, and present them as an API for possible
    modification. It can then write out the regenerated file.
    """

    def __init__(self, filename):
        """Open file and parse it."""
        self.modified = False
        self.filename = filename
        with open(filename, 'rt') as infile:
            contents = infile.read()
        self.parse_lines(contents)

    @staticmethod
    def parser_coroutine(contents):
        """
        Accept a sequence of regexps that contents must match, yielding matched strings.

        The contents must match each regexp in order.

        Exits once all the contents have been consumed.
        """
        match = None
        while len(contents) > 0:
            regexp = yield match.group() if match else None
            match = re.match(regexp, contents, re.DOTALL | re.MULTILINE | re.VERBOSE)
            if not match:
                raise ParseError("did not match expected regexp")
            contents = contents[match.end():]
        yield match.group()  # Last group...shouldn't ever return

    def parse_lines(self, contents):
        """Go through contents (one giant string) to find what we need."""
        parser = self.parser_coroutine(contents)
        next(parser)  # prime the coroutine
        front_matter = parser.send(r"""
                           \A     # beginning of file
                           .*?    # match as few as possible
                           ^      # beginning of line
                           \$GLACIERSCRIPT  # Run script
                           \s+ -- # beginning of --testnet or --regtest
                        """)
        testmode = parser.send(r"""
                       (testnet|regtest)
                    """)
        if testmode == 'testnet':
            testmode = 'regtest'
            self.modified = True
        cmdline_storage_and_dest = parser.send(r"""
                            =\$1 \s create-withdrawal-data \s \<\< \s INPUT \n  # rest of cmdline
                            (y\n){6}       # safety confirmations
                            2[0-9a-zA-Z]+ \n  # cold storage address
                            [0-9a-fA-F]+ \n   # redeem script
                            [0-9a-zA-Z]+ \n   # destination address
                        """)
        input_tx_count = int(parser.send(r"""
                            \d+ \n
                        """))
        self.input_txs = []
        for idx in range(input_tx_count):
            tx = parser.send(r"""
                            [0-9a-fA-F]+ \n   # input tx
                        """).rstrip()
            self.input_txs.append(tx)
        back_matter = parser.send(r"""
                            .* \Z  # everything up to the end
                        """)
        self.front_matter = front_matter \
                            + testmode \
                            + cmdline_storage_and_dest \
                            + str(input_tx_count) \
                            + "\n"
        self.back_matter = back_matter

    def save(self):
        if not self.modified:
            return
        with atomic_write(self.filename) as outfile:
            outfile.write(self.front_matter)
            outfile.write("\n".join(self.input_txs))
            outfile.write("\n")  # one more after last input tx
            outfile.write(self.back_matter)


def convert_one_file(filename):

    """
    Convert one *.run file from testnet to regtest.
    """
    runfile = ParsedRunfile(filename)
    #for intx in runfile.input_txs:
    #    print("Found input tx: {}".format(intx))
    runfile.save()


def convert(args):
    """
    Parse a *.run test input, convert it from testnet to regtest (if needed),
    save the generated input transactions in file tx.json,
    write out new *.run file with its input transactions replaced with regtest versions.

    We must run start() first, to be sure the current blockchain is in a known state,
    before we start creating additional transactions.

    TODO: It's important that our updates of tx.json happen before the *.run script is rewritten.
    That way, if we get interrupted between those two, the next time we run, we'll find our
    transactions in tx.json and everything will just work. If we did it in the opposite order,
    we'd leave things in a broken state.
    """
    start(args)
    for runfile in args.runfile:
        print("Converting {} to regtest...".format(runfile))
        try:
            convert_one_file(runfile)
        except ParseError:
            print("*** Error converting that one. This is expected, if this test doesn't actually create any withdrawal transaction.")
    stop(args)


def stop(_):
    if bitcoin_cli.call('stop') == 0:
        # in case already running, wait a bit for it to exit
        time.sleep(1)

    try:
        shutil.rmtree('bitcoin-online-data')
    except FileNotFoundError:
        pass  # we don't care if it wasn't already there


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
        This tool is used to control an "online" Bitcoin node for testing Glacier.
    """, epilog="Run <subcommand> --help for more about that subcommand.")
    parser.add_argument('-v', '--verbose', action='store_true', help='increase output verbosity')
    subparsers = parser.add_subparsers(title='Subcommands')

    parser_start = subparsers.add_parser(
        'start',
        help="Start the regtest server",
        description=textwrap.dedent("""\
        Start the regtest server and create transactions as expected
        by test withdrawals.

        This will read tx.json (TODO) to find the list of transactions
        to create, and will parse all the *.run files to ensure that
        the transactions constructed match what the run files use as
        inputs. (TODO)

        Glacier's Makefile runs this command once before running any
        tests.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_start.set_defaults(program=start)

    parser_submit = subparsers.add_parser(
        'submit',
        help="Submit a withdrawal transaction to the network",
        description=textwrap.dedent("""\
        Parse a *.golden test output, and submit its withdrawal
        transaction to bitcoind. Fail if not accepted and mined into
        the regtest blockchain. Also writes out a *.decoded file to
        document the constructed transaction in the git history.

        Glacier's Makefile runs this command after running any test
        with a filename of "*withdrawal*". Temp TODO: the *.run file
        must also have --regtest for the Makefile to run this.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_submit.set_defaults(program=submit)
    parser_submit.add_argument('goldenfile')

    parser_convert = subparsers.add_parser(
        'convert',
        help="Convert a test's *.run from testnet to regtest",
        description=textwrap.dedent("""\
        Parse one or more *.run files, which must be withdrawal tests,
        and look for transactions used as inputs. Convert each from
        testnet to regtest (if needed), save the generated
        input transactions in file tx.json (TODO), and write out new
        *.run files with all input transactions replaced with regtest
        versions (TODO).

        Test developers are expected to run this once after
        hand-creating any new tests via testnet.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_convert.set_defaults(program=convert)
    parser_convert.add_argument('runfile', nargs='+')

    parser_stop = subparsers.add_parser(
        'stop',
        help="Stop the regtest server",
        description=textwrap.dedent("""\
        Stop the bitcoind regtest server started previously by the
        `start` subcommand, and delete the bitcoin-online-data dir
        that it was using as its data directory.

        Glacier's Makefile runs this command once after all tests
        pass.
        """),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_stop.set_defaults(program=stop)

    args = parser.parse_args()

    bitcoin_cli.verbose_mode = args.verbose

    args.program(args)
